---
title: Insert, Modify, ModifyAll, Delete, and DeleteAll Methods
description: Describes how to use the Insert, Modify, ModifyAll, Delete, and DeleteAll methods in Business Central
ms.date: 09/15/2025
ms.topic: article
author: SusanneWindfeldPedersen
ms.author: solsen
ms.reviewer: solsen
---

# Insert, Modify, ModifyAll, Delete, DeleteAll, and Truncate methods

The following methods maintain the database by adding, modifying, and removing records:  

- [Insert](methods-auto/record/record-insert--method.md)  
- [Modify](methods-auto/record/record-modify-method.md)  
- [ModifyAll](methods-auto/record/record-modifyall-method.md)  
- [Delete](methods-auto/record/record-delete-method.md)  
- [DeleteAll](methods-auto/record/record-deleteall-method.md)
- [Truncate](methods-auto/record/record-truncate-method.md)

These methods are some of the most frequently used AL methods.  

Some of these methods return an optional Boolean value that indicates whether the method succeeded. If you don't handle the return value in your code, a runtime error occurs when a method returns **false**. If you handle the return value by testing its value in an **if** statement, no error occurs, and you must take corrective action in the code.  

## Insert method

The Insert method inserts a record in a table. Insert has the following syntax.
<!--
```  
[Ok :=] Record.Insert([RunTrigger])  
```  
-->
```AL
[Ok := ]  Record.Insert([RunTrigger: Boolean[, InsertWithSystemId: Boolean]])
```  

A record must be assigned a **SystemId**. You have the option to assign your own value or have the platform assign an autogenerated value. The following example inserts a new record, with the **SystemId**, **No.**, and **Name** fields specified in the assigned values, while other fields have their default values. If the **No.** field is the primary key of the **Customer** table, then the record is inserted in the **Customer** table unless the table already contains a record with the same primary key. In this case, you receive an error message because the return value isn't tested.  

```AL
var
    Customer: Record Customer;
begin
    Customer.Init;
    Customer.SystemId := '{B6666666-F5A2-E911-8180-001DD8B7338E}';  
    Customer."No." := '4711';  
    Customer.Name := 'Andrew Dixon';  
    Customer.Insert(false, true);
end; 
```  

> [!IMPORTANT]
> After the **SystemId** is set on a record, it can't be changed.

## Modify method

Modify modifies a record that already exists. Learn more in [Modify method](methods-auto/record/record-modify-method.md). Modify has the following syntax:

```AL 
[Ok :=] Record.Modify([RunTrigger])  
```  

Modify returns an optional Boolean value. It returns **true** if the record to be modified exists; otherwise, it returns **false**.  

The following example changes the name of customer 4711 to Richard Roe. This example requires that you create the following variable.  

|Variable|Data type|Subtype|  
|--------------|---------------|-------------|  
|Customer|Record|Customer|  

```AL 
Customer.Get('4711');  
Customer.Name := 'Richard Roe';  
Customer.Modify;  
```  

## ModifyAll method

ModifyAll performs a bulk update of records. Learn more in [ModifyAll method](methods-auto/record/record-modifyall-method.md). ModifyAll has the following syntax:

```AL  
Record.ModifyAll(Field, NewValue [, RunTrigger])  
```  

ModifyAll uses the current filters. This means that you can perform the update on a specified set of records in a table. ModifyAll returns no value, nor does it cause an error if the set of records to be changed is empty.  

In the following example, the `SetRange` statement selects the records where Salesperson Code is PS. The ModifyAll statement changes the Salesperson Code of these records to JR. The example requires that you create the following variable.  

|Variable|Data type|Subtype|  
|--------|---------|-------|  
|Customer|Record|Customer|  

```AL  
Customer.SetRange("Salesperson Code",'PS','PS');  
Customer.ModifyAll("Salesperson Code",'JR');  
```  

## Delete method

Delete deletes a record from the database. Learn more in [Delete method](methods-auto/record/record-delete-method.md). Delete has the following syntax.  

```AL  
[Ok :=] Record.Delete([RunTrigger])  
```  

The record that you want to delete must be specified by using the values in the primary key fields before you call this method. This means that Delete does take filters into consideration.  

The following example shows how to use Delete to delete the record for customer number 4711. This example requires that you create the following variable.  

|Variable|Data type|Subtype|  
|--------|---------|-------------|  
|Customer|Record|Customer|  

```AL  
Customer."No." := '4711';  
Customer.Delete;  
```  

Delete returns an optional Boolean value. It returns **true** if the record could be found; otherwise, it returns **false**. Unless you test this value in your code, a run-time error occurs when Delete fails.  

When you're developing your own applications, you should consider the following scenario:  

1. Retrieve a record from the database.  
2. Perform various checks to determine whether the record should be deleted.  
3. If step 2 indicated that you should delete the record, then delete it.  

This can cause problems in a multi-user environment. Another user can modify or delete the same record between your performing steps 2 and 3. If the record is modified, then perhaps the new contents of the record would have changed your decision to delete it. If it has been deleted by the other user, you can get a run-time error if you have verified that the record existed (in step 1). If the design of your application indicates that you can encounter this problem, you should consider using the LockTable method. LockTable should be used sparingly because this method degrades performance. Learn more about the LockTable method in [LockTable method](methods-auto/record/record-locktable-method.md).  

## DeleteAll method

DeleteAll deletes all the records that are specified by the filter settings. If no filters are applied, it deletes all the records in the table. Learn more in [DeleteAll method](methods-auto/record/record-deleteall-method.md). DeleteAll has the following syntax:

```AL  
Record.DeleteAll([RunTrigger])  
```  

The following example deletes all the records from the **Customer** table where the Salesperson Code is PS. This example requires that you create the following variable.  

|Variable|Data type|Subtype|  
|--------------|---------------|-------------|  
|Customer|Record|Customer|  

```AL  
Customer.SetRange("Salesperson Code", 'PS', 'PS');  
Customer.DeleteAll;  
```  

> [!NOTE]  
> When you use DeleteAll (true), a copy of the AL variable with its initial values is created. This means that when you use DeleteAll(true) to run the OnDelete trigger, all the changes that were made to the variables in the method or codeunit that's making the call, can't be seen in the OnDelete trigger. If you want to see the changes that you made to the variables, you must use Delete(true) in a loop. There's no difference in performance between using DeleteAll(true) and using Delete(true) in a loop.

## Truncate method

Like Delete, the Truncate method also deletes records from a table. However, the Truncate method provides a high-performance way to remove large volumes of rows from a table by skipping row‑by‑row deletions. Instead of iterating and deleting each row, the platform uses a bulk operation that significantly reduces execution time and logging overhead. The method offers options to either reset AutoIncrement values to 0 or preserve their previous values. It also validates delete permissions before running.

Truncate has the following syntax:

```AL  
[Ok := ]  Record.Truncate([ResetAutoIncrement: Boolean])
```

If you supply filters, the platform copies the rows you want to keep to a temporary table, truncates the original table, and then moves the kept rows back. This process maintains the speed benefits of bulk deletion while allowing filtered removals, but it does add extra input/output operations.

The following example deletes all the records from the **MyTable** table where the Location Code is Red. This example requires that you create the following variable.  

|Variable|Data type|Subtype|  
|-|-|-|  
|MyRec|Record|MyTable|  

```AL  
MyRec.SetRange("Location Code", 'Red');
Ok :=  MyRec.Truncate(true)
```

## When to use Truncate or DeleteAll

Use Truncate when you need to clear or massively reduce a table quickly (for example: cleanup, reset between tests, or bulk archival workflows). For selective or small deletions, a standard Delete (row-by-row with WHERE) is preferable because it’s lighter for small sets and behaves predictably with triggers and per-row constraints. DeleteAll (removing every row without a WHERE) is simpler but typically slower than Truncate for very large tables, as it may still trigger per-row operations such as triggers or constraints.

Truncate isn't supported in the following cases, so use DeleteAll instead:

- Temporary tables, system tables, and tables of type other than Normal.
- When running within a try function.
- Tables that have a security filter applied.
- When the current filters contain flow fields, or use a high number of marked records.
- When there are event subscribers for the OnAfterDelete or OnBeforeDelete triggers of the table.
- Tables with media fields.

Use Truncate with a filter only when you intend to delete a significant number of the rows in the table. If you need to remve a relatively small number of rows, DeleteAll is generally more efficient.

## Related information

[AL methods](./methods-auto/library.md)  
[AL Language reference overview](index.md)  
[SystemId field](devenv-table-system-fields.md#systemid)
